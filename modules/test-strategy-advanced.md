# 고급 테스트 전략 가이드
의견요? 한 줄 요약부터 하죠: **뼈대는 괜찮지만, 실전 ROI 기준으로는 군살이 많습니다.** 몇 군데는 괜히 스스로 유지보수 지옥 입장권 끊는 구성이에요. 아래처럼 정리하면 “테스트가 일 잘하게” 됩니다.

# 1) 우선순위 재정렬 (꼰대식 직설 버전)

1. **에러 처리(필수 필드/잘못된 타입/변환 실패)**: 최우선. 맵퍼의 존재 이유가 이거죠. 실패를 아름답게 실패시키는지부터 봐야 합니다.
2. **돈·정합성 로직(가격/세금/반올림/통화 단위)**: 두 번째. 부정확하면 바로 사고. 부동소수점 오차 방지용으로 `decimal.js` 같은 고정소수 전략도 테스트 포함.
3. **엣지 케이스(빈 문자열/null/undefined/특수문자/날짜 파싱 실패)**: 세 번째. 이건 에러 처리와 붙여서 “입력 정규화 계약”을 명확히.
4. **통합 테스트(스키마, Supabase 타입 호환)**: 네 번째. 단, “진짜 DB 붙여 돌리는” 건 필수 경로만 얇게. 나머지는 계약 테스트로 충분.
5. **성능 테스트**: 다섯 번째. 단위 테스트에 끼워넣지 말고, 간단 벤치(대용량 N 레코드 변환 시간 상한)만 별도 스위트로. 매 PR 전체 돌리는 건 금지.
6. **스냅샷 테스트**: 최하. 구조 잦은 변경에 취약. “불변 스키마의 복잡한 결과”에만 제한적으로.

# 2) 설계 관점에서 빠진 것들

* **런타임 스키마 검증**: TypeScript 타입만 믿고 가면 실제 런타임에서 뻗습니다. `zod`/`valibot`으로 입력 스키마 정의하고, 맵퍼 입구에서 검증. 테스트는 “스키마 통과/실패”를 기준으로 작성.
* **프로퍼티 기반 테스트(빠른 가치)**: 태그에 임의 유니코드, 공백/구두점 섞인 값, 랜덤 금액/세율로 “불변식(invariants)” 검증. “출력 합계는 항목 합의 합” 같은 규칙을 fuzz로 보장.
* **계약 테스트(Contract Test)**: “맵퍼 출력 ↔ DB 스키마” 사이의 계약을 작은 샘플 스키마로 고정 검사. 실제 DB 띄우지 않고도 깨질 변경을 조기에 잡습니다.
* **시간 의존성 통제**: 날짜 파싱/타임존 로직 있으면 `fakeTimers`로 고정. 테스트 환경의 로컬 타임존에 흔들리면 바로 지옥문.
* **테스트 데이터 빌더(Test Data Builder)**: 매 케이스마다 객체를 수동 조립하지 말고 빌더로 가독성/재사용성 확보.

# 3) “깨지기 쉬운 테스트” 방지 규칙

* 구현 세부에 집착 금지. “정렬 방식”이 요구사항이 아니면 `toContainEqual`/`expect.arrayContaining` 사용.
* 에러 메시지는 “코드/에러 종류”를 주검증 포인트로, 풀 텍스트 일치 금지.
* 스냅샷은 “스키마 안정 + 사람 눈으로 봐야 가치 있는 구조”에만. 나머지는 명시적 어서션으로.

# 4) 제안하는 파일 구성(현실판)

```
__tests__/
  unit/
    utils/
      courseDataMapper.success.test.ts     // 정상 케이스 + 돈/반올림 규칙
      courseDataMapper.errors.test.ts      // 스키마 실패/필수 누락/타입 오류
      courseDataMapper.fuzz.test.ts        // 프로퍼티 기반(경량)
  contract/
    mapper.schema.contract.test.ts         // zod 스키마 ↔ 출력 계약
    supabase.types.contract.test.ts        // 생성된 타입과 최소 호환 확인
  integration/
    courseDataMapper.db.integration.test.ts // 필수 경로만, in-memory or test DB
  perf/
    courseDataMapper.bench.test.ts         // 대용량 변환 시간 상한(스킵 기본)
```

# 5) 케이스 샘플 체크리스트

* 금액 로직

  * [ ] 정가, 퍼센트 할인, 정액 할인, 세금 순서 규칙 고정
  * [ ] 반올림 규칙(half up/half even) 명시
  * [ ] 엣지: 0원, 초고가, 세금 0, 음수 방지
* 입력 정규화

  * [ ] 빈 문자열→null 규칙 혹은 그대로 유지, 둘 중 하나로 계약 고정
  * [ ] 태그: 트리밍, 중복 제거, 특수문자 허용 범위
  * [ ] 날짜: ISO 외 형식 실패 시 오류 or 기본값, 정책 일관
* 에러 표준화

  * [ ] `ZodError` → 내부 `DomainError` 변환 여부, 코드/필드 경로 노출 정책
* 통합/계약

  * [ ] Supabase 생성 타입 파일(import)과 맵퍼 출력 간 호환성 체크
  * [ ] 마이그레이션 시 깨지는 필드 조기 경고
* 비기능

  * [ ] 대량 N=100k 변환 95p 지연 < X ms (로컬 기준, CI는 스킵)
  * [ ] 메모리 피크 < Y MB (옵션)

# 6) 스냅샷 대신 명시 어서션 예시

```ts
// 나쁜 예(스냅샷 남발)
// expect(mapCourse(input)).toMatchSnapshot();

// 좋은 예(명시)
const out = mapCourse(input);
expect(out.price.final).toBe("123.45");        // 문자열 통화 포맷 고정
expect(out.tags).toEqual(expect.arrayContaining(["ai", "무료"]));
expect(out.startsAt).toBe("2025-09-01T00:00:00Z"); // 타임존 포함 고정
```

# 7) 성능 테스트 운용 원칙

* CI 기본은 **스킵**. `CI_PERF=1` 때만 실행.
* 실패 기준은 절대값이 아니라 **회귀 감지** 중심(직전 기준 +X% 초과 시 경고).
* 퍼포먼스는 리그레이션 체크지, 정확성 검증 수단이 아닙니다.

# 8) 커버리지 숫자 농담 그만

“70 → 90%”는 팀 사기를 올리는 데 쓸 수는 있지만, 품질을 담보하진 않습니다. **리스크 기반 커버리지**를 목표로 하세요. 돈·보안·데이터 정합성 라인 100% 가까이, 나머지는 적정선.

---

## 결론

* **좋은 점**: 엣지/에러/통합을 분리해서 보는 관점은 합격.
* **수정할 점**: 스냅샷 과다, 성능을 단위 스위트에 끼워넣기, 커버리지 숫자 집착.
* **추가할 것**: 런타임 스키마 검증, 프로퍼티 기반 테스트, 계약 테스트, 시간 고정, 데이터 빌더.

당연히 “CSS 색상 테스트” 같은 건 버리세요. 그런 데 시간 쓰면, 다음 스프린트 회고에서 또 “왜 일정 밀렸냐”고 묻겠죠.
